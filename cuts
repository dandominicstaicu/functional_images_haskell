

-- -- General function to optimize binary operations (Union, Intersection)
-- optimizeBinaryOp :: (RegionAST -> RegionAST -> RegionAST) -> RegionAST -> RegionAST -> RegionAST
-- optimizeBinaryOp constructor reg1 reg2 =
--     let optimizedReg1 = optimizeTransformations reg1
--         optimizedReg2 = optimizeTransformations reg2
--     in case (optimizedReg1, optimizedReg2) of
--         (Transform t1 r1, Transform t2 r2) ->
--             if t1 == t2  -- If the transformations are the same, lift them up
--             then Transform t1 (constructor r1 r2)
--             else constructor optimizedReg1 optimizedReg2  -- Apply transformations separately if different
--         _ -> constructor optimizedReg1 optimizedReg2

-- -- Helper to combine transformations
-- combineTransformations :: [TransformationAST] -> TransformationAST
-- combineTransformations [transformation] = transformation
-- combineTransformations transformations = Combine transformations

-- -- Helper to apply a transformation to a region
-- applyTransformation :: TransformationAST -> RegionAST -> RegionAST
-- applyTransformation (Combine []) region = region
-- applyTransformation transformation region = Transform transformation region


-- fuseTransformations :: [TransformationAST] -> [TransformationAST]
-- fuseTransformations = foldr fuse []
--   where
--     fuse :: TransformationAST -> [TransformationAST] -> [TransformationAST]
--     fuse t [] = [t]  -- If the list is empty, start with the current transformation
--     fuse t (x:xs)
--       | canFuse t x = (fuseSingle t x) : xs  -- If they can fuse, fuse them and continue
--       | otherwise = t : x : xs  -- Otherwise, add the current transformation to the result list

--     canFuse :: TransformationAST -> TransformationAST -> Bool
--     canFuse (Translation _ _) (Translation _ _) = True
--     canFuse (Scaling _) (Scaling _) = True
--     canFuse _ _ = False

--     fuseSingle :: TransformationAST -> TransformationAST -> TransformationAST
--     fuseSingle (Translation dx1 dy1) (Translation dx2 dy2) = Translation (dx1 + dx2) (dy1 + dy2)
--     fuseSingle (Scaling s1) (Scaling s2) = Scaling (s1 * s2)
--     fuseSingle x _ = x  -- Default case should not be hit due to prior checks


-- decomposeTransformation :: TransformationAST -> [TransformationAST]
-- decomposeTransformation (Translation dx dy) = [Translation dx dy]
-- decomposeTransformation (Scaling factor) = [Scaling factor]
-- decomposeTransformation (Combine transformations) =
--     concatMap decomposeTransformation transformations

-- combineTransformations :: [TransformationAST] -> TransformationAST
-- combineTransformations [transformation] = transformation
-- combineTransformations transformations = Combine transformations

-- applyTransformation :: TransformationAST -> RegionAST -> RegionAST
-- applyTransformation (Combine []) region = region
-- applyTransformation transformation region = Transform transformation region

